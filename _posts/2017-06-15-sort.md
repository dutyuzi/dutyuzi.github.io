---
layout:     post
title:      "七种常见经典排序算法总结（C++实现）"
subtitle:   "sort"
date:        2017/06/14  15:29:00 
author:     "MaJ"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 算法
---
---

# 一、冒泡排序(Bubble Sort) #
冒泡排序是最简单粗暴的排序方法之一。它的原理很简单，每次从左到右两两比较，把大的交换到后面，每次可以确保将前M个元素的最大值移动到最右边。
## 步骤 ##
1. 从左开始比较相邻两个元素x和y，如果x>y就交换两者
2. 对第0个到第n-1个数据做同样的工作。这时最大的数就“浮”在最右
3. 针对所有元素重复以上步骤，除了最后一个
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

![img](/img/bubble.gif)

## 代码实现 ##

	void bubble_sort(vector<int> &nums)
	{
		for (int i = 0; i < nums.size() - 1; i++) { // times
			for (int j = 0; j < nums.size() - i - 1; j++) { // position
				if (nums[j] > nums[j + 1]) {
					int temp = nums[j];
					nums[j] = nums[j + 1];
					nums[j + 1] = temp;
				}
			}
		}
	}

***tips***

交换的那一步可以不借助tmp，方法是：

	nums[j] += nums[j + 1];
	nums[j + 1] = num[j] - nums[j + 1];
	nums[j] -= num[j + 1];
或者

    nums[j] = nums[j]^nums[j+1];
	nums[j + 1] = nums[j]^nums[j+1];
	nums[j] = nums[j]^nums[j+1];

## 复杂度 ##
由于我们要重复执行n次冒泡，每次冒泡要执行n次比较（实际是1到n的等差数列，也就是(a1 + an) * n / 2），时间复杂度也就是 O(n^2)。 空间复杂度是O(n)。

# 二、插入排序（Insertion Sort） #

插入排序的原理是从左到右，把选出的一个数和前面的数进行比较，找到最适合它的位置放入，使前面部分有序。

## 步骤 ##
1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果被扫描的元素（已排序）大于新元素，将该元素后移一位
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置，将新元素插入到该位置后
5. 重复步骤2~4


![img](/img/insertion.gif)

## 代码实现 ##

	void insert_sort(vector<int> &nums)
	{
		for (int i = 1; i < nums.size(); i++)
		{
			for (int j = i; j >= 0; j--)
			{
				if (nums[j] > nums[j + 1])
				{
					nums[j] = nums[j] + nums[j + 1];
					nums[j + 1] = nums[j] - nums[j + 1];
					nums[j] = nums[j] - nums[j + 1];
				}
			}
		}
	
	}

## 复杂度 ##
因为要选择n次，而且插入时最坏要比较n次，所以时间复杂度同样是O(n^2)。空间复杂度是O(n)。

# 选择排序 #
选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

## 步骤 ##
1. 从左开始，选择后面元素中最小值，和最左元素交换
2. 从当前已交换位置往后执行，直到最后一个元素

![img](/img/selection.gif)

## 代码实现 ##

	void selection_sort(vector<int> &nums)
	{
		for (int i = 0; i < nums.size(); i++)
		{
			int min = i;
			for (int j = i; j < nums.size(); j++)
			{
				if (nums[j] < nums[min])
				{
					min = j;
				}
			}
	
			int tmp = nums[i];
			nums[i] = nums[min];
			nums[min] = tmp;
		}
	}

## 复杂度 ##

每次要找一遍最小值，最坏情况下找n次，这样的过程要执行n次，所以时间复杂度还是O(n^2)。空间复杂度是O(n)。

### 参考
