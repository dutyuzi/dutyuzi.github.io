---
layout:     post
title:      "C++ 值传递、指针传递、引用传递详解"
subtitle:   "parameter passing"
date:        2017/05/24  13:01:39 
author:     "MaJ"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - C++
---

### 值传递

形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参->形参），参数的值只能传入，
不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。

### 指针传递

形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。

### 引用传递

形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈
中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过
栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。

下面代码直观展示：

	#include<iostream>
	using namespace std;
	//值传递
	void change1(int n){
	    cout<<"值传递--函数操作地址"<<&n<<endl;         //显示的是拷贝的地址而不是源地址 
	    n++;
	}
	
	//引用传递
	void change2(int & n){
	    cout<<"引用传递--函数操作地址"<<&n<<endl; 
	    n++;
	}
	 //指针传递
	void change3(int *n){
	     cout<<"指针传递--函数操作地址 "<<n<<endl; 
	    *n=*n+1;
	 } 

	int main()
	{
	    int n=10;
	    cout<<"实参的地址"<<&n<<endl;
	    change1(n);
	    cout<<"after change1() n="<<n<<endl;
	    change2(n);
	    cout<<"after change2() n="<<n<<endl;
	    change3(&n);
	    cout<<"after change3() n="<<n<<endl;
	    return true;
	}

程序运行结果：

![img](/img/parapassing.jpg)
 
可以看出实参的地址是0x7fff5cb192cc
值传递函数操作的地址不是实参地址，所以实参值不变。引用和指针传递时，操作地址都是实参地址，所以实参值会改变。

**指针传递和引用传递一般适用于**：

1、函数内部修改参数并且希望改动影响调用者。对比指针/引用传递可以将改变由形参“传给”实参（实际上就是直接在实参的内存上修改，
不像值传递将实参的值拷贝到另外的内存地址中才修改）。

2、另外一种用法是：当一个函数实际需要返回多个值，而只能显式返回一个值时，可以将另外需要返回的变量以指针/引用传递
给函数，这样在函数内部修改并且返回后，调用者可以拿到被修改过后的变量，也相当于一个隐式的返回值传递吧。

### 指针与引用

在C和C++中，指针一般指的是某块内存的地址，通过这个地址，我们可以寻址到这块内存；而引用是一个变量的别名，例如我们给小明起了个外号：明明，那我们说明明的时候，就是说小明。
对于指针来说，它是一个地址，这个地址是一个数值，那么就意味这个数值可以为0(空指针)，也可以为其他，即指针可以不指向任何东西。
而对于引用来说，他是一个外号，外号一定是“某个存在物体”的外号，所以引用不能为空，即不能存在空引用。
根据以上可知指针和引用的一个重要不同：指针可以为空，引用不能为空。这就意味着我们拿到一个引用的时候，是不需要判断引用是否为空的，而拿到一个指针的时候，我们则需要判断它是否为空。这点经常在判断函数参数是否有效的时候使用。例如：

	void fun1(int *point)
	{
	     // 为了代码的稳健和安全，我们需要判断指针是否有效,通常做法是判断指针是否为
	     // 空，其他的判断就需要根据函数的具体功能来判断了
	     if(!point)
	     {
	        return;
	     }
	     // 函数实现
	}

	void fun2(int &refence)
	{
	     // 在这里，我们就不用担心refence是否为空
	}

引用修饰函数参数还可以提高效率，例子如下：

	Class Object
	{
		// 实现省略，只需要知道我们在这里声明了一个类，在下面我们要将这个类的对象作为函数参数类型来使用
	
	};
	
	void fun1(Object obj)
	{
	     // 此函数声明中，obj是值传递，会产生一个临时对象
	}
	
	void fun2(Object &obj)
	{
	    // 我们不用检查obj是否为空，同时，使用引用传递，可以避免临时对象
	}

我们根据前面的描述，还可以知道指针可以多次赋值，即在某时刻可以指向地址1，换个时候可以指向地址2，例如：

	int a = 0;
	int b = 1;
	int *point = NULL;
	point = &a;     // 在某个时刻，指针可以指向a
	point = &b;     // 换个时刻，指针可以指向b

而引用则不同，引用只能在初始化的时候就赋好值，之后就不能改变了，用外号的例子来说就是"明明"这个外号在出现的时候就是代指小明，之后“明明”这个外号就绑在小明身上了，它不能过段时间换成小暗的外号。
代码如下：

	int xiaoming = 1;
	int &refence_mingming = xiaoming;
	int xiaoan = 2;
	refence_mingming = xiaoan; // error,引用不能换了

由以上可以，当我们需要某个是否指向为空的时候，我们就需要使用指针了，还有指向的对象需要变化的时候，我们也需要使用指针。其他地方一般推荐引用。


## 参考
[C++ 值传递、指针传递、引用传递详解](http://www.cnblogs.com/yanlingyin/archive/2011/12/07/2278961.html/)

[c++中，引用和指针的区别是什么？](https://www.zhihu.com/question/37608201/)


